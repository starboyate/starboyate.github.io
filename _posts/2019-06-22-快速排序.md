---
layout: post
title: "快速排序"
subtitle: 'java实现'
author: "Starboyate"
header-img: "img/singleton.jpg"
multilingual: true
tags:
  - 算法
---

## 一、前言

> 排序算法是我们学程序最经典最基础的算法，所以我们应该熟练的掌握排序算法

<br/>

## 二、快速排序
##### 1.什么是快速排序呢？

> wiki定义：快速排序，又称划分交换排序，简称快排，一种排序算法，最早由东尼·霍尔提出。
在平均状况下，排序个项目要次比较。在最坏状况下则需要次比较，但这种状况并不常见。
事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率地达成

##### 2.快速排序算法描述
> 每次选择一个元素作为分界点，然后通过递归算法进行划分，把小于分界点的元素放置分界点左边，
大于分界点的元素放置分界点右边，循环此操作，直至数组待排序数组不可划分为止。

<br/>


![快速排序](https://img-blog.csdn.net/20150805112443608)


##### 3.第一版快速排序算法实现
```java
public class QuickSort {
    public static void sort(int[] nums) {
        // 调用辅助函数，进行真正的逻辑
        sort(nums, 0, nums.length - 1);
    }

    private static void sort(int[] nums, int left, int right) {
        // 当left >= right就代表已经全部划分完了，所以这是终止条件
        if (left >= right) {
            return;
        }
        // 进行划分操作
        int p = partition(nums, left, right);
        sort(nums, left, p - 1);
        sort(nums, p + 1, right);
    }

    private static int partition(int[] nums, int left, int right) {
        // 选择第一个元素作为分界点
        int e = nums[left];
        // 记录每次对比的元素的想赢下标
        int j = left;
        for (int i = left + 1; i <= right; i ++) {
            // 比分界点小的元素我们才需要交换为止，因为比分界点大的元素本来就是在分界点的右边
            if (nums[i] < e) {
                swap(nums, j + 1, i);
                j ++;
            }
        }
        // 记录了分界点应该存在的下标，然后和第一个下标也就是left进行交换
        swap(nums, left, j);
        return j;
    }

    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```
