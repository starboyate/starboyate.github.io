---
layout: post
title: "如何设计一个注册中心(中)"
subtitle: '注册中心杂谈'
author: "Starboyate"
header-img: "img/singleton.jpg"
multilingual: true
tags:
  - 分布式
  - 微服务
---

## 一、前言
> 在上一篇博客[如何设计一个注册中心(上)](http://starboyate.com/2019/07/05/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83(%E4%B8%8A)/)
简单的介绍了注册中心，这篇就来讲讲如何设计一个可用的注册中心的两大核心功能，服务注册和服务发现。

<br/>

## 二、正文
#### 1.服务注册
> 既然是注册中心，那肯定得有注册功能，让服务可以进行注册，然后才可以实现服务发现，那么应该如何设计这个服务注册的功能呢？
其实服务注册，说白了就是个把当前服务自身的一些信息发送给注册中心。下面来看看如何设计

<br/>

##### 1.1 注册信息的设计
> 因为我们的注册中心，本来就是为了提供服务发现，所以需要我们每个服务把对应的信息注册到注册中心上面去，
但是我们需要什么信息呢？

- 首先，是不是最基本的要有 ip + port，没有这两个信息，服务之间也无法进行调用发现
- 其次是不是应该还有一些服务的元数据，比如当前服务的唯一标识，版本等等
- 我们如果要实现一些高大上的功能，是不是还要有例如当前服务所在的机房机器，当前服务的心跳一些数据，用于健康检查等等

<br/>

如何获取IP呢（这里就列举两种）？
- 最简单的方式就是，通过手动配置，然后我们解析对应的文件就可以获取
- 遍历网卡，第一个不为本地环回地址的 IP 地址，很多开源框架都是如此来获取的，比如netty，dubbo。

<br/>

如何获取端口呢？
- 如果是spring boot项目，我相信很多用过spring boot的朋友都知道如何获取，可以通过实现ApplicationListener接口，通过WebServerInitializedEvent来进行获取
- 通过获取配置文件上的配置的端口来获取，比如，spring boot项目就是@Value("${server.port:8080}")。

<br/>

如何生成服务的元数据呢（列举一些，其余的应该自己做好扩展）？
- 服务Id(Id): 我们的Id，要尽量让它具有意义，而不应该只是一堆UUID生成的随机无意义串，可以使用时间戳 + 机房 + 当前工作机器 + 序列号来生成。
- 服务名(ServiceName)：这个我们应该是通过配置文件里面手动配置来获取
- 版本(version)：服务的版本，这个也应该是通过配置文件里面配置来获取，有了版本是不是就可以做类似灰度发布等功能。
- 注册时间(registerTime)：服务注册的时间戳

<br/>

如何生成一些其它的信息用于更高级的功能？
- 健康检查：例如检查的次数，检查的间隔时间等等，也是通过配置文件来进行获取
- 分区相关信息：比如当前的区域，机房，机器，这个也应该是通过配置文件来获取
- 集群同步的信息：比如配置使用多个注册中心，这个也是通过多个配置文件来获取

<br/>

ok,上面已经简单的设计了注册信息的实体类，接下来是不是应该调用对应的注册中心提供的注册接口来进行发送了，那么我们应该如何设计这个
注册中心的这个注册接口呢？

##### 1.2 注册中心的注册接口的设计
> 既然设计到了发送数据，调用接口这里，那么就离不开一个问题，我们应该选择什么样的方式或者说什么样的协议进行发送，这也就对应着
我们的服务注册中心应该制定一个什么样的对外暴露的协议呢？其实无非就是选择http restful接口这样的方式还是rpc tcp这样的方式呢，下面来分析下，两种的优劣

- Http Restful方式调用: 相信做java web这块的一定不陌生了，现在只要我们使用spring boot，做的接口大部分都是restful这样的方式，
那使用http有什么优缺呢？首先http是位于网络模型中最上层的应用层，所以相对现在的dubbo，thift等等rpc组件，肯定性能上是差一截的，
但是使用http优点就是安全、简单。
- RPC TCP方式调用：使用TCP好处就是性能好，速度快，当然这也是相对http来说，我们可以使用一些优秀的开源库，比如netty来进行开发。

<br/>

> 上面如果选好了要使用哪种通信协议方式，那么接下来是不是要设计如何存储这个其它服务注册上面的注册信息啊，下面来看看，首先来看看
现在市面上流行的开源的注册中心组件是如何做的

```text
zookeeper: 相信如果有看前面[如何设计一个注册中心(上)](http://starboyate.com/2019/07/05/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83(%E4%B8%8A)/)
就一定清楚了zookeeper的CAP模型是属于CP，为了强一致性牺牲了可用性，zookeeper是基于paxos实现了一个ZAB算法来实现强一致性的，那从这里就可以知道竟然是强一致性了，那么肯定其它服务注册上来的注册信息，
肯定是做了对应的持久化。

eureka: netflix公司开源的eureka注册中心是AP模型的，之前文章也讨论了，其实eureka才是真正适合做注册中心的，因为我们注册中心是需要AP而不是CP，eureka在注册信息这块，是直接在内存中进行存储的，通过一个
类似HashMap这样的容器来进行存储。

```

那么我们应该如何设计存储这块呢？
- 对于一些元数据，例如当前服务的版本等等，我们其实应该做持久化的，然后还要提供API给用户来进行查看
- 其实大部分数据我们是不需要做持久化的，因为其实这些数据持久化下来，其实是没有太多意义的。


那么现在就是这个样子

<br/>

![06](/img/register-06.png)

<br/>

#### 2.服务发现
> 因为注册中心就是为了提供给各个服务在复杂的分布式网络中，提供可靠的信息，用于进行调用，所以服务发现这个功能
是必不可少的，那么应该如何来实现这个服务发现呢？

##### 2.1 Pull还是Push？
> 在说服务拉取之前，我们先看一个问题,就是pull和push的问题，先来看一个例子，现在我有两个服务，需要去注册中心拉取信息，如下图

![07](/img/register-07.png)

如果现在，突然有个服务C加进来了，也要往注册中心进行注册，那么这时候，是不是应该要通知给其他已经注册了的服务，如下图

<br/>

![08](/img/register-08.png)

这时候应该如何通过给其他的注册了的服务呢？其实有两种方式，下面来分析下
- push：就是注册中心直接去通知给其它已经注册的服务，告诉它们有新的服务过来了，需要重新拉取信息了，但是这里会有什么问题吗
其实首先，要实现这样的push的方式相对比较复杂，其次当现在注册的服务已经达到了成千上万个，那我需要一个个的去通知，这里就是相当于
要发n（n为注册服务个数）个请求，这样肯定就会影响性能。
- pull: 这样的方式就是让我每个注册的服务都定时的往注册中心那里进行拉取，这样的方式会有什么问题呢，就会存在一个不够实时，延时的问题，
但其实这都是可以接受的，所以pull的方式比push方式更适合。

<br/>

##### 2.2 服务拉取
> 上面说了我们服务拉取其实应该用pull的方式，所以，下面我们基于这个方式，来设计我们的服务拉取


- 首先我们同样在客户端这里使用内存来存储拉取的注册信息。
- 接着我们需要做一层过滤，比如，我定时去拉取的注册信息，很有可能跟我现在在内存中存储的数据是一样的，并没有改变，那么我们可以
在注册中心存储注册信息的容器中做一个版本号，每次拉取的时候，都进行CAS对比，如果版本是一样的，那么就不需要拉取传输数据，当有新的
服务注册上去注册中心的时候，是不是应该更新现在在注册中心存储的注册实体信息的容器的版本号，这样就可以做到了一定程度上的优化
- 然后我们拉取的信息是不是就是简单的存储在内存中就可以了呢？答案是否，我们还需要做一个区分，因为其实我们是在一个分布式的环境下，
那么前面我们说的注册信息里面也包括了诸如当前服务的机房，工作机器等这样的信息，所以我们应该把拉取下来的注册信息也根据同机房、同机器
的进行划分，为什么需要这样划分呢？因为是不是处于同一个机房，同一区域的，调用肯定会比其它的速度快啊，所以我们这样划分后，就形成了优先
调用处于同区域，同机房的服务，如果调用不到，再考虑去调用其它地方的。

<br/>

## 三、尾语
> 这里讲了如何设计注册中心的两个核心功能，服务注册和服务发现，希望可以考虑上面的设计是不是就可以了，还有没有可以优化的地方，后面还会陆续介绍其它高级功能，
加油 ！







